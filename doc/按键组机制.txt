
• 按键组的进入：
首先不存在1、2、7模式（单键、快捷键、连点）的按键，然后是本按键的按下沿，开始进入
记录本按键（因为需要记住是哪个按键导致进入的按键组模式）
读取按键组数据的起始地址
一些计数变量和标志变量初始化
先插入间隔标志
执行一次按键组处理函数

• 之后的报文填写主函数的轮询：
发现仍在按键组模式，便不再处理其他按键，下面继续处理按键组
若按键组按键出现释放沿，需要记录，这里要记录两个信息，一个是记录释放沿，一个是是否是第一释放沿
间隔标志先翻转，这里提前翻转是为了之后报文控制功能方便
若翻转后间隔标志为真，则代表翻转前为假，则本次需要执行按键组处理函数

在报文填写函数末尾，若发现延时标志为真，则禁止发送任何报文

• 按键组处理函数：
若有未到的延时，则保持延时标志为真，间隔标志为假，return
接下来，也就是没有未到的延时，则延时标志置假
结束位置置0，若仍在按键组模式，则获取真正的结束位置
接下来进入循环，自动退出条件为键盘报文填满：
{
    若计数变量>=结束位置，代表按键组数据已读完，则清0按键组模式标志，break（最后的空报文由外部机制实现）
    若有报文控制：首先记录之，并记录是新的报文控制字节，然后决定是否清掉间隔标志，和是否break。
    或有延时：计算延时完成时间，若有新记录的报文控制字节，则：
    {
        清除新标志。
        若为NoGap则令延时标志为真，间隔标志为假。
    }
    或有循环：若为起始，则记录起始地址，continue。否则即为循环结束：
    {
        循环计数递增。并获取循环设定次数。
        若自动模式操作退出或非自动模式操作退出或循环计数结束退出，则结束标志置位。
        若结束标志置位，则把各种标志和计数复位，结束循环；
        否则继续循环，若起始地址有效则跳回循环开头，否则跳回按键组开头。
    }
    或有快捷键：若本次键鼠报文已有内容则等下次，否则填入快捷键并break独占。
    或有光标：
    或有shift：
    最后else只能看作普通按键：
}




• 举例：
[1][2][1][2][3]
报文1：12123	报文2：空

[1][2][1000ms][1][2][3]
报文1：12（填完12发现有延时，跳出，自动逻辑会使下一次是间隔）
报文2：空（由于间隔，自动使用空报文）
报文3：123

[1][2][ReportCtrl:NoEnd,NoGap][1000ms][1][2][3]
报文1：12
首先填完12，然后发现报文控制NoGap，取消下一次间隔
继续，发现延时，跳出，之后报文1真正发出
等待延时完毕，期间保持延时标志为真，且保持间隔标志为假，没有报文发出
报文2：123
报文3：空

通过报文控制记录的实现：（现已弃用）
[1][2][ReportCtrl:End,NoGap][1000ms][1][2][3]
报文1：12（填完12发现报文控制End，跳出，且发现NoGap，取消下一次间隔）
下一次发现延时，跳出，且发现记录的NoGap，直接置延时标志，以此禁用报文发送
等待延时完毕，期间保持延时标志为真，且保持间隔标志为假
报文2：123
报文3：空


































